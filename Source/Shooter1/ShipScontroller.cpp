// Fill out your copyright notice in the Description page of Project Settings.


#include "ShipScontroller.h"
#include "Components/BoxComponent.h"
#include "Components/InputComponent.h"
#include"BulletController.h"
#include"EnemyController.h"
#include "Kismet/GameplayStatics.h"
#include"SpaceShooterGameMode.h"

// Sets default values
AShipScontroller::AShipScontroller()
{
 	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	//A box generally used for simple collision. Bounds are rendered as lines in the editor.
	CollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT("Root"));//este component recebe a string Root
	CollisionBox->SetGenerateOverlapEvents (true);
	CollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AShipScontroller::OnOverlap);

	//Determines which PlayerController, if any, should automatically possess the pawn when the level starts or when the pawn is spawned.
	AutoPossessPlayer = EAutoReceiveInput::Player0;//
}

// Called when the game starts or when spawned
void AShipScontroller::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AShipScontroller::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	if (!CurrentVelocity.IsZero())//se a velocidade nao for 0
	{
		FVector NewLocation = GetActorLocation() + Speed * CurrentVelocity
			* DeltaTime;//recebe a actual localizacao do pawn e soma o speed*veloc*delta
		SetActorLocation(NewLocation);//set the pawn location to the value generated by NewLocation
	}
}

// Called to bind functionality to input
void AShipScontroller::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
	//aqui vamos fazer o bind das keys que foram introduzidas no Input para fazer mexer o pawn
	InputComponent->BindAxis("MoveX",this,&AShipScontroller::Move_XAxis);
	InputComponent->BindAxis("MoveY", this, &AShipScontroller::Move_yAxis);
	//vamos fazer o bind da tecla que foi escolha no menu Input para fazer o <Shoot quando pressionada
	InputComponent->BindAction("Shoot", IE_Pressed, this, &AShipScontroller::OnShoot);
	InputComponent->BindAction("Restart", IE_Pressed, this, &AShipScontroller::OnRestart).bExecuteWhenPaused=true;
}

void AShipScontroller::Move_XAxis(float AxisValue)
{
	CurrentVelocity.X = AxisValue * 100.0f;//altera o valor de x o que faz o personagam mover
}

void AShipScontroller::Move_yAxis(float AxisValue)
{
	CurrentVelocity.Y = AxisValue * 100.0f;
}

void AShipScontroller::OnShoot()
{
	UWorld* World = GetWorld();//Getter for the cached world pointer, will return null if the actor is not actually spawned in a level

	if (World)
	{
		FVector Location = GetActorLocation();
		Location.X += 100;

		World->SpawnActor<ABulletController>(BulletBlueprint, Location, FRotator::ZeroRotator);//vai gerar uma bala no local onde se encontra o actor(neste caso o shipController), axo ke ABulletController è o codigo da bala. e BulletBlueprint è o menu no Unreal onde podemos escolher o local para leter a buller blueprint
	}
}

void AShipScontroller::OnRestart()
{
	if (Died)
	{
		UGameplayStatics::OpenLevel(this, FName(*GetWorld()->GetName()), false);
	}
}

void AShipScontroller::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (OtherActor->IsA(AEnemyController::StaticClass()))
	{
		Died = true;
		this->SetActorHiddenInGame(true);

		((ASpaceShooterGameMode*)GetWorld()->GetAuthGameMode())->OnGameOver();

		UGameplayStatics::SetGamePaused(GetWorld(), true);
	}
}


